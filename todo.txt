/*set QTextStream for QString
*make QStruct Coefficient
*coefficient is member of equation class,
*equation is member in matrix class;

*matrix class (maybe better to add matrix members to eqsolver class instead of making a new matrix class)
    *has 3 member equations, as in the 3 matrix lines
    *has a function to initialize the equations, which in turn initialize the coefficients
        *init equation
            *check if lineEdits have text in them, if all three do, then create equation object
    *has an equation vector{eq1,eq2,eq2}, to run isolateVar(Char varToIsolate)  ...(CREEP!!)
    *has solve matrix function   ...(CREEP!!)

*equation class
    *Constructor uses 3 Coefficients
    *has 3 member vector of 3 lineEdits ui->x_1,ui->y_1...
    *has 3 member coefficients x,y,z
            //getText(ui->lineEditVector[i])
    *has a coefficient vector

*Coefficient class
    *has QString fractionRep = lineEdit
    *has double doubleValue = numerInt/denomInt
    *has QString numerString, denomString
    *has int numerInt, denomInt=1
    *has bool hasDenom = false
    *constructor uses fractionRep, and builds all the rest from there
	*fractionRep is the string obtained from the selected ui->lineEdit
    *Coefficient(lineEdit.text())
	*initialize fractionrep with lineEdit.text()
	*getNumer()
	*if hasDenom = true then getDenom()

//function to get prime factorization of number
std::vector<int> factorsRecursive(int n, std::vector<int> factorVector{})
{	
    if(n==1)
        return factors;
    else
    {
        for(i = 2; i<=n; i++)
        {
            if(n%i==0)
            {
                factorVector.push_back(i);
                factorsRecursive(n/i, factorVector);
	    }
        }
    }
}

//function to compare prime factorizations
//int commonfactors = 1;
//if member in common, commonfactors *= vectorb[i]
vectorb[i] = 1;
